{% comment %} {
  "root": true,
  "parser": "@typescript-eslint/parser",
  "plugins": [
    "@typescript-eslint",
    "prettier"
  ],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:@typescript-eslint/recommended", 
    "airbnb", 
    "prettier", 
    "plugin:node/recommended"
  ],
  "parserOptions": {
    "ecmaVersion": 2018
  },
  "rules": {
    "prettier/prettier": "error",
    "spaced-comment": "off",
    "no-console": "warn",
    "consistent-return": "off",
    "func-names": "off",
    "object-shorthand": "off",
    "no-process-exit": "off",
    "no-param-reassign": "off",
    "no-return-await": "off",
    "no-underscore-dangle": "off",
    "class-methods-use-this": "off",
    "prefer-destructuring": ["error", { "object": true, "array": false }],
    "no-unused-vars": ["error", { "argsIgnorePattern": "req|res|next|val" }]
  },
  "overrides": [
    {
      // 2. Enable the Markdown processor for all .md files.
      "files": ["**/*.md"],
      "processor": "markdown/markdown"
    },
    {
      // 3. Optionally, customize the configuration ESLint uses for ```js
      // fenced code blocks inside .md files.
      "files": ["**/*.md/*.js"],
      // ...
      "rules": {
        // ...
      }
    }
  ]
} {% endcomment %}

{% comment %} {
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "singleQuote": true,
  "trailingComma": "none",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "fluid": false
}

import request from 'supertest';
// import mongoose from 'mongoose';
import app from '@src/app';
import User from '@src/models/userModel';

beforeEach(async () => {
  // Clear the User DB to have a clean slate
  await User.deleteMany();
});

// beforeEach(done => {
//   mongoose.connect(
//     process.env.MONGODB_LOCAL_TEST_URI as string,
//     { useNewUrlParser: true, useUnifiedTopology: true },
//     () => done()
//   );
// });

// afterEach(done => {
//   mongoose.connection.db.dropDatabase(() => {
//     mongoose.connection.close(() => done());
//   });
// });

describe('Auth API endpoints', () => {
  describe('Signup user @ POST /api/auth', () => {
    describe('Valid username and password', () => {
      // it('should respond with a 201 status code', async () => {
      //   const response = await request(app)
      //     .post('/api/v1/auth/signup')
      //     .send(mockSignupUser)
      //     // .expect('Content-Type', /json/)
      //     .expect(201);
      //   const { data } = response.body;
      //   expect(response.body).toMatchObject({
      //     status: true,
      //     data: {
      //       user: {},
      //       token: data.token,
      //     },
      //   });
      // });
      const mockSignupUser = {
        name: 'theophilus',
        email: 'theophilus@gmail.com',
        password: 'ighalo',
        confirmPassword: 'ighalo',
      };
      it('should respond with a 201 status code', async () => {
        const res = await request(app).post('/api/v1/auth/signup').send(mockSignupUser);
        expect(res.statusCode).toBe(201); // Don't use toBe() with floating point numbers.
      });

      it('should specify json in the content-type header', async () => {
        const res = await request(app).post('/api/v1/auth/signup').send(mockSignupUser);
        expect(res.headers['content-type']).toEqual(expect.stringContaining('json'));
      });
    });

    // describe('Invalid username and password', () => {
    //   it('should specify json in the content-type header', async () => {
    //     const res = await request(app).post('/api/v1/auth/signup').send(mockSignupUser);
    //     expect(res.headers['content-type']).toEqual(expect.stringContaining('json'));
    //   });
    // });
  });
});

// describe('Auth API endpoints', () => {
//   const mockSignupUser = {
//     name: 'theophilus',
//     email: 'theophilus@gmail.com',
//     password: 'ighalo',
//     confirmPassword: 'ighalo',
//   };

//   describe('Signup user @ POST /api/auth', () => {
//     describe('Valid username and password', () => {
//       it('should respond with a 201 status code', async () => {
//         const res = await request(app).post('/api/v1/auth/signup').send(mockSignupUser);
//         expect(res.statusCode).toBe(201); // Don't use toBe() with floating point numbers.
//       });

//       it('should specify json in the content-type header', async () => {
//         const res = await request(app).post('/api/v1/auth/signup').send(mockSignupUser);
//         expect(res.statusCode).toBe(400);
//       });
//     });

//     describe('Invalid username and password', () => {
//       it('should specify json in the content-type header', async () => {
//         const res = await request(app).post('/api/v1/auth/signup').send(mockSignupUser);
//         expect(res.headers['content-type']).toEqual(expect.stringContaining('json'));
//       });
//     });
//   });
// });
it('should respond with a 201 status code', () => {
        return request(app)
          .post('/api/v1/auth/signup')
          .send(mockSignupUser)
          .expect('Content-Type', /json/)
          .expect(201)
          .then(response => {
            expect(response.body).toEqual(
              expect.objectContaining({
                status: expect.any(Boolean),
              })
            );
          });
      });


      # # Query type
# # type Query {

# # }

# # Mutation type
# type Mutation {
#   signup: (credentials: SignupInput) => MutationResponse,
#   login: (credentials: LoginInput) => MutationResponse
# }

# interface MutationResponse {
#   code: String!
#   success: Boolean!
#   message: String!
# }


# # User - Object type
# type User {
#   _id: ID
#   name: String!  # Scalar type
#   email: String! # Scalar type
#   avatar: String! # Scalar type
#   role: Role!  # Scalar type
#   isActive: Boolean! # Scalar type
# }

# #Cart - Object types
# # This "Cart" Object type defines the queryable fields for every cart in our data source
# type Cart {
#   _id: ID
#   products: [CartProduct]!
#   cartTotal: Float!
#   totalAfterDiscount: Float
#   orderedBy: User!
# }

# type CartProduct {
#   _id: ID
#   product: ID;
#   count: Int;
#   color: String;
#   price: Float;
# }

# # SignupInput - Input type
# input SignupInput {
#   email: String! # Scalar type
#   name: String! # Scalar type
#   password: String! # Scalar type
# }

# # LoginInput - Input type
# input LoginInput {
#   email: String! # Scalar type
#   password: String! # Scalar type
# }

# enum Roles {
#   CUSTOMER
#   BUSINESS
#   ADMIN
# } {% endcomment %}
